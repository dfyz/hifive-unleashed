From a053a52b00d7c9d89172af066b564962ea54bdeb Mon Sep 17 00:00:00 2001
From: Ivan Komarov <Ivan.Komarov@dfyz.info>
Date: Sun, 17 Mar 2019 20:21:21 +0300
Subject: [PATCH] Apply patches to make HiFive Unleashed work with
 linux-next-20190306

---
 .../bindings/clock/sifive,gemgxl-mgmt.txt     |   26 +
 .../bindings/clock/sifive,u54-prci.txt        |   44 +
 .../devicetree/bindings/gpio/gpio-sifive.txt  |   28 +
 .../devicetree/bindings/pwm/pwm-sifive.txt    |   28 +
 drivers/clk/Kconfig                           |    1 +
 drivers/clk/Makefile                          |    1 +
 drivers/clk/sifive/Kconfig                    |    9 +
 drivers/clk/sifive/Makefile                   |    2 +
 drivers/clk/sifive/gemgxl-mgmt.c              |  129 ++
 drivers/clk/sifive/u54-prci.c                 |  314 +++++
 drivers/gpio/Kconfig                          |    7 +
 drivers/gpio/Makefile                         |    1 +
 drivers/gpio/gpio-sifive.c                    |  322 +++++
 drivers/mtd/spi-nor/spi-nor.c                 |   47 +-
 drivers/net/phy/mdio_bus.c                    |    3 -
 drivers/pwm/Kconfig                           |   10 +
 drivers/pwm/Makefile                          |    1 +
 drivers/pwm/pwm-sifive.c                      |  252 ++++
 drivers/spi/Kconfig                           |    7 +
 drivers/spi/Makefile                          |    1 +
 drivers/tty/serial/Kconfig                    |   23 +
 drivers/tty/serial/Makefile                   |    1 +
 drivers/tty/serial/sifive.c                   | 1051 +++++++++++++++++
 include/linux/mtd/spi-nor.h                   |    2 +
 include/uapi/linux/serial_core.h              |    3 +
 25 files changed, 2309 insertions(+), 4 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/clock/sifive,gemgxl-mgmt.txt
 create mode 100644 Documentation/devicetree/bindings/clock/sifive,u54-prci.txt
 create mode 100644 Documentation/devicetree/bindings/gpio/gpio-sifive.txt
 create mode 100644 Documentation/devicetree/bindings/pwm/pwm-sifive.txt
 create mode 100644 drivers/clk/sifive/Kconfig
 create mode 100644 drivers/clk/sifive/Makefile
 create mode 100644 drivers/clk/sifive/gemgxl-mgmt.c
 create mode 100644 drivers/clk/sifive/u54-prci.c
 create mode 100644 drivers/gpio/gpio-sifive.c
 create mode 100644 drivers/pwm/pwm-sifive.c
 create mode 100644 drivers/tty/serial/sifive.c

diff --git a/Documentation/devicetree/bindings/clock/sifive,gemgxl-mgmt.txt b/Documentation/devicetree/bindings/clock/sifive,gemgxl-mgmt.txt
new file mode 100644
index 000000000000..349489e33eda
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/sifive,gemgxl-mgmt.txt
@@ -0,0 +1,26 @@
+TX clock switch for GEMGXL in U540 SoCs
+
+This binding uses the common clock binding:
+    Documentation/devicetree/bindings/clock/clock-bindings.txt
+
+The U54 includes a clock mux to control the ethernet TX frequenecy. It
+switches between the local TX clock (125MHz) and PHY TX clocks. This is
+necessary to toggle between 1Gb and 100/10Mb speeds.
+
+Required properties:
+- compatible:	Should be "sifive,cadencegemgxlmgmt0"
+- #clock-cells:	Should be <0>
+- reg:		Specifies base physical address and size of the registers
+
+Example:
+
+	mgmt: cadence-gemgxl-mgmt@100a00000 {
+		compatible = "sifive,cadencegemgxlmgmt0";
+		#clock-cells = <0>;
+		reg = <0x0 0x100a0000 0x0 0x1000>;
+	};
+
+	ethernet@10090000 {
+		...
+		clocks = <&mgmt>; /* TX clock */
+	};
diff --git a/Documentation/devicetree/bindings/clock/sifive,u54-prci.txt b/Documentation/devicetree/bindings/clock/sifive,u54-prci.txt
new file mode 100644
index 000000000000..88682c5eaebc
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/sifive,u54-prci.txt
@@ -0,0 +1,44 @@
+SiFive U54 SoC clocks
+
+This binding uses the common clock binding:
+    Documentation/devicetree/bindings/clock/clock-bindings.txt
+
+The U54 PRCI controller generates clocks for the U54 SoC. There is
+a core PLL that sets the processor frequency and PLLs for ethernet
+and DDR. It takes an input clock from the board, typically an oscillator
+or crystal.
+
+Required properties:
+- compatible:	Should be "sifive,aloeprci0"
+- #clock-cells:	Should be <1>
+- reg:		Specifies base physical address and size of the registers
+- clocks:	phandles to the parent clock used as input
+
+Example:
+
+	refclk: refclk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <33333333>;
+		clock-output-names = "xtal";
+	};
+
+	u54: prci@10000000 {
+		compatible = "sifive,aloeprci0";
+		reg = <0x0 0x10000000 0x0 0x1000>;
+		clocks = <&refclk>;
+		#clock-cells = <1>;
+	};
+
+	tlclk: tlclk {
+		compatible = "fixed-factor-clock";
+		clocks = <&u54 0>; /* Core frequency */
+		#clock-cells = <0>;
+		clock-div = <2>;
+		clock-mult = <1>;
+	};
+
+	ethernet@10090000 {
+		...
+		clocks = <&prci 1>; /* TX clock */
+	};
diff --git a/Documentation/devicetree/bindings/gpio/gpio-sifive.txt b/Documentation/devicetree/bindings/gpio/gpio-sifive.txt
new file mode 100644
index 000000000000..bf41eed81dbf
--- /dev/null
+++ b/Documentation/devicetree/bindings/gpio/gpio-sifive.txt
@@ -0,0 +1,28 @@
+SiFive GPIO controller bindings
+
+Required properties:
+- compatible:
+  - "sifive,gpio0"
+- reg: Physical base address and length of the controller's registers.
+- #gpio-cells : Should be 2
+  - The first cell is the gpio offset number.
+  - The second cell indicates the polarity of the GPIO
+- gpio-controller : Marks the device node as a GPIO controller.
+- interrupt-controller: Mark the device node as an interrupt controller
+- #interrupt-cells : Should be 2.
+  - The first cell is the GPIO offset number within the GPIO controller.
+  - The second cell is the edge/level to use for interrupt generation.
+- interrupts: Specify the interrupts, one per GPIO
+
+Example:
+
+gpio: gpio@10060000 {
+	compatible = "sifive,gpio0";
+	interrupt-parent = <&plic>;
+	interrupts = <7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22>;
+	reg = <0x0 0x10060000 0x0 0x1000>;
+	gpio-controller;
+	#gpio-cells = <2>;
+	interrupt-controller;
+	#interrupt-cells = <2>;
+};
diff --git a/Documentation/devicetree/bindings/pwm/pwm-sifive.txt b/Documentation/devicetree/bindings/pwm/pwm-sifive.txt
new file mode 100644
index 000000000000..7cea20db58e5
--- /dev/null
+++ b/Documentation/devicetree/bindings/pwm/pwm-sifive.txt
@@ -0,0 +1,28 @@
+SiFive PWM controller
+
+Unlike most other PWM controllers, the SiFive PWM controller currently only
+supports one period for all channels in the PWM. This is set globally in DTS.
+The period also has significant restrictions on the values it can achieve,
+which the driver rounds to the nearest achievable frequency.
+
+Required properties:
+- compatible: should be "sifive,pwm0"
+- reg: physical base address and length of the controller's registers
+- clocks: The frequency the controller runs at
+- #pwm-cells: Should be 2.
+  The first cell is the PWM channel number
+  The second cell is the PWM polarity
+- sifive,approx-period: the driver will get as close to this period as it can
+- interrupts: one interrupt per PWM channel (currently unused in the driver)
+
+Examples:
+
+pwm:  pwm@10020000 {
+	compatible = "sifive,pwm0";
+	reg = <0x0 0x10020000 0x0 0x1000>;
+	clocks = <&tlclk>;
+	interrupt-parent = <&plic>;
+	interrupts = <42 43 44 45>;
+	#pwm-cells = <2>;
+	sifive,approx-period = <1000000>;
+};
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index e705aab9e38b..d100a6ae5cdd 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -315,5 +315,6 @@ source "drivers/clk/tegra/Kconfig"
 source "drivers/clk/ti/Kconfig"
 source "drivers/clk/uniphier/Kconfig"
 source "drivers/clk/zynqmp/Kconfig"
+source "drivers/clk/sifive/Kconfig"
 
 endmenu
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 1db133652f0c..62ba714e34b1 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -93,6 +93,7 @@ obj-$(CONFIG_COMMON_CLK_QCOM)		+= qcom/
 obj-y					+= renesas/
 obj-$(CONFIG_ARCH_ROCKCHIP)		+= rockchip/
 obj-$(CONFIG_COMMON_CLK_SAMSUNG)	+= samsung/
+obj-y					+= sifive/
 obj-$(CONFIG_ARCH_SIRF)			+= sirf/
 obj-$(CONFIG_ARCH_SOCFPGA)		+= socfpga/
 obj-$(CONFIG_PLAT_SPEAR)		+= spear/
diff --git a/drivers/clk/sifive/Kconfig b/drivers/clk/sifive/Kconfig
new file mode 100644
index 000000000000..284bffb121eb
--- /dev/null
+++ b/drivers/clk/sifive/Kconfig
@@ -0,0 +1,9 @@
+config CLK_U54_PRCI
+	bool "PRCI driver for U54 SoCs"
+	---help---
+	  Supports Power Reset Clock interface found in U540 SoCs
+
+config CLK_GEMGXL_MGMT
+	bool "TX clock switch for GEMGXL in U540 SoCs"
+	---help---
+	  Supports clock muxing between 10/100Mbit and 1Gbit TX clock on U540 SoCs
diff --git a/drivers/clk/sifive/Makefile b/drivers/clk/sifive/Makefile
new file mode 100644
index 000000000000..7784d2ee0f44
--- /dev/null
+++ b/drivers/clk/sifive/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_CLK_U54_PRCI)	+= u54-prci.o
+obj-$(CONFIG_CLK_GEMGXL_MGMT)	+= gemgxl-mgmt.o
diff --git a/drivers/clk/sifive/gemgxl-mgmt.c b/drivers/clk/sifive/gemgxl-mgmt.c
new file mode 100644
index 000000000000..00b07580fe3c
--- /dev/null
+++ b/drivers/clk/sifive/gemgxl-mgmt.c
@@ -0,0 +1,129 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Copyright (C) 2018 SiFive, Inc.
+ */
+
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+struct sifive_gemgxl_mgmt {
+	void __iomem *reg;
+	unsigned long rate;
+	struct clk_hw hw;
+};
+
+#define to_sifive_gemgxl_mgmt(mgmt) container_of(mgmt, struct sifive_gemgxl_mgmt, hw)
+
+static unsigned long sifive_gemgxl_mgmt_recalc_rate(struct clk_hw *hw,
+				      unsigned long parent_rate)
+{
+	struct sifive_gemgxl_mgmt *mgmt = to_sifive_gemgxl_mgmt(hw);
+	return mgmt->rate;
+}
+
+static long sifive_gemgxl_mgmt_round_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long *parent_rate)
+{
+	if (WARN_ON(rate < 2500000)) {
+		return 2500000;
+	} else if (rate == 2500000) {
+		return 2500000;
+	} else if (WARN_ON(rate < 13750000)) {
+		return 2500000;
+	} else if (WARN_ON(rate < 25000000)) {
+		return 25000000;
+	} else if (rate == 25000000) {
+		return 25000000;
+	} else if (WARN_ON(rate < 75000000)) {
+		return 25000000;
+	} else if (WARN_ON(rate < 125000000)) {
+		return 125000000;
+	} else if (rate == 125000000) {
+		return 125000000;
+	} else {
+		WARN_ON(rate > 125000000);
+		return 125000000;
+	}
+}
+
+static int sifive_gemgxl_mgmt_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long parent_rate)
+{
+	struct sifive_gemgxl_mgmt *mgmt = to_sifive_gemgxl_mgmt(hw);
+	rate = sifive_gemgxl_mgmt_round_rate(hw, rate, &parent_rate);
+	iowrite32(rate != 125000000, mgmt->reg);
+	mgmt->rate = rate;
+	return 0;
+}
+
+static const struct clk_ops sifive_gemgxl_mgmt_ops = {
+	.recalc_rate = sifive_gemgxl_mgmt_recalc_rate,
+	.round_rate = sifive_gemgxl_mgmt_round_rate,
+	.set_rate = sifive_gemgxl_mgmt_set_rate,
+};
+
+static int sifive_gemgxl_mgmt_probe(struct platform_device *pdev)
+{
+	struct clk_init_data init;
+	struct sifive_gemgxl_mgmt *mgmt;
+	struct resource *res;
+	struct clk *clk;
+
+	mgmt = devm_kzalloc(&pdev->dev, sizeof(*mgmt), GFP_KERNEL);
+	if (!mgmt)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mgmt->reg = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(mgmt->reg))
+		return PTR_ERR(mgmt->reg);
+
+	init.name = pdev->dev.of_node->name;
+	init.ops = &sifive_gemgxl_mgmt_ops;
+	init.flags = 0;
+	init.num_parents = 0;
+
+	mgmt->rate = 0;
+	mgmt->hw.init = &init;
+
+	clk = clk_register(NULL, &mgmt->hw);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	of_clk_add_provider(pdev->dev.of_node, of_clk_src_simple_get, clk);
+
+	dev_info(&pdev->dev, "Registered clock switch '%s'\n", init.name);
+
+	return 0;
+}
+
+static const struct of_device_id sifive_gemgxl_mgmt_of_match[] = {
+	{ .compatible = "sifive,cadencegemgxlmgmt0", },
+	{}
+};
+
+static struct platform_driver sifive_gemgxl_mgmt_driver = {
+	.driver	= {
+		.name = "sifive-gemgxl-mgmt",
+		.of_match_table = sifive_gemgxl_mgmt_of_match,
+	},
+	.probe = sifive_gemgxl_mgmt_probe,
+};
+
+static int __init sifive_gemgxl_mgmt_init(void)
+{
+	return platform_driver_register(&sifive_gemgxl_mgmt_driver);
+}
+core_initcall(sifive_gemgxl_mgmt_init);
diff --git a/drivers/clk/sifive/u54-prci.c b/drivers/clk/sifive/u54-prci.c
new file mode 100644
index 000000000000..edc4b7818e71
--- /dev/null
+++ b/drivers/clk/sifive/u54-prci.c
@@ -0,0 +1,314 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Copyright (C) 2018 SiFive, Inc.
+ */
+
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/log2.h>
+
+#define CORE_CLOCK 0
+#define GEMTX_CLOCK 1
+#define PRCI_CLOCKS 2
+
+#define MIN_REF 7000000UL
+#define MAX_REF 200000000UL
+#define MAX_PARENT 600000000UL
+#define MAX_VCO 4800000000UL
+#define MAX_DIV 64
+#define MAX_R 64UL
+
+#define PLL_LOCK 0x80000000U
+#define NAME_LEN 40
+
+struct sifive_u54_prci_driver;
+
+struct sifive_u54_prci_pll {
+	struct clk_hw hw;
+	struct sifive_u54_prci_driver *driver;
+	char name[NAME_LEN];
+	u32 freq;
+	u32 glcm;
+};
+
+struct sifive_u54_prci_driver {
+	struct clk_onecell_data table;
+	struct clk *clks[PRCI_CLOCKS];
+	struct sifive_u54_prci_pll plls[PRCI_CLOCKS];
+	void __iomem *reg;
+};
+
+#define to_sifive_u54_prci_pll(hw) container_of(hw, struct sifive_u54_prci_pll, hw)
+
+struct sifive_u54_pll_cfg {
+	unsigned long r, f, q, a;
+};
+
+static struct sifive_u54_pll_cfg sifive_u54_pll_cfg(u32 reg)
+{
+	struct sifive_u54_pll_cfg cfg;
+	cfg.r = (reg >>  0) & 0x3f;
+	cfg.f = (reg >>  6) & 0x1ff;
+	cfg.q = (reg >> 15) & 0x7;
+	cfg.a = (reg >> 18) & 0x7;
+	return cfg;
+}
+
+static u32 sifive_u54_pll_reg(struct sifive_u54_pll_cfg cfg)
+{
+	u32 reg = 0;
+	reg |= (cfg.r & 0x3f)  << 0;
+	reg |= (cfg.f & 0x1ff) << 6;
+	reg |= (cfg.q & 0x7)   << 15;
+	reg |= (cfg.a & 0x7)   << 18;
+	reg |= 1<<25; // internal feedback
+	return reg;
+}
+
+static unsigned long sifive_u54_pll_rate(struct sifive_u54_pll_cfg cfg, unsigned long parent)
+{
+	return (parent*2*(cfg.f+1) / (cfg.r+1)) >> cfg.q;
+}
+
+static struct sifive_u54_pll_cfg sifive_u54_pll_configure(unsigned long target, unsigned long parent)
+{
+	struct sifive_u54_pll_cfg cfg;
+	unsigned long scale, ratio, best_delta, filter;
+	u32 max_r, best_r, best_f, r;
+
+	/* Confirm input frequency is within bounds */
+	if (WARN_ON(parent > MAX_PARENT)) { parent = MAX_PARENT; }
+	if (WARN_ON(parent < MIN_REF))    { parent = MIN_REF; }
+
+	/* Calculate the Q shift and target VCO */
+	scale = MAX_VCO / target;
+	if (scale <= 1) {
+		cfg.q = 1;
+		target = MAX_VCO;
+	} else if (scale > MAX_DIV) {
+		cfg.q = ilog2(MAX_DIV);
+		target = MAX_VCO/2;
+	} else {
+		cfg.q = ilog2(scale);
+		target = target << cfg.q;
+	}
+
+	/* Precalcualte the target ratio */
+	ratio = (target << 20) / parent;
+
+	/* Placeholder values */
+	best_r = 0;
+	best_f = 0;
+	best_delta = MAX_VCO;
+
+	/* Consider all values for R which land within [MIN_REF, MAX_REF]; prefer smaller R */
+	max_r = min(MAX_R, parent / MIN_REF);
+	for (r = DIV_ROUND_UP(parent, MAX_REF); r <= max_r; ++r) {
+		/* What is the best F we can pick in this case? */
+		u32 f = (ratio*r + (1<<20)) >> 21;
+		unsigned long ref = parent / r;
+		unsigned long vco = ref * f * 2;
+		unsigned long delta;
+
+		/* Ensure rounding didn't take us out of range */
+		if (vco > target) --f;
+		if (vco < MAX_VCO/2) ++f;
+		vco = ref * f * 2;
+
+		delta = abs(target - vco);
+		if (delta < best_delta) {
+			best_delta = delta;
+			best_r = r;
+			best_f = f;
+		}
+	}
+
+	cfg.r = best_r - 1;
+	cfg.f = best_f - 1;
+
+	/* Pick the best PLL jitter filter */
+	filter = parent / best_r;
+	BUG_ON(filter < 7000000);
+	if (filter < 11000000) {
+		cfg.a = 1;
+	} else if (filter < 18000000) {
+		cfg.a = 2;
+	} else if (filter < 30000000) {
+		cfg.a = 3;
+	} else if (filter < 50000000) {
+		cfg.a = 4;
+	} else if (filter < 80000000) {
+		cfg.a = 5;
+	} else if (filter < 130000000) {
+		cfg.a = 6;
+	} else {
+		BUG_ON (filter > 200000000);
+		cfg.a = 7;
+	}
+
+	return cfg;
+}
+
+static unsigned long sifive_u54_prci_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct sifive_u54_prci_pll *pll = to_sifive_u54_prci_pll(hw);
+	struct sifive_u54_prci_driver *driver = pll->driver;
+
+	u32 reg = ioread32(driver->reg + pll->freq);
+	struct sifive_u54_pll_cfg cfg = sifive_u54_pll_cfg(reg);
+
+	return sifive_u54_pll_rate(cfg, parent_rate);
+}
+
+static long sifive_u54_prci_round_rate(struct clk_hw *hw, unsigned long rate, unsigned long *parent_rate)
+{
+	struct sifive_u54_pll_cfg cfg = sifive_u54_pll_configure(rate, *parent_rate);
+	return sifive_u54_pll_rate(cfg, *parent_rate);
+}
+
+static int sifive_u54_prci_set_rate(struct clk_hw *hw, unsigned long rate, unsigned long parent_rate)
+{
+	struct sifive_u54_prci_pll *pll = to_sifive_u54_prci_pll(hw);
+	struct sifive_u54_prci_driver *driver = pll->driver;
+
+	struct sifive_u54_pll_cfg cfg = sifive_u54_pll_configure(rate, parent_rate);
+	u32 reg = sifive_u54_pll_reg(cfg);
+
+	/* Switch to reg clock and reconfigure PLL */
+	iowrite32(1, driver->reg + pll->glcm);
+	iowrite32(reg, driver->reg + pll->freq);
+
+	/* Wait for lock and switch back to PLL */
+	while (!(ioread32(driver->reg + pll->freq) & PLL_LOCK));
+	iowrite32(0, driver->reg + pll->glcm);
+
+	return 0;
+}
+
+static const struct clk_ops sifive_u54_prci_ops_rw = {
+	.recalc_rate = sifive_u54_prci_recalc_rate,
+	.round_rate = sifive_u54_prci_round_rate,
+	.set_rate = sifive_u54_prci_set_rate,
+};
+
+static const struct clk_ops sifive_u54_prci_ops_ro = {
+	.recalc_rate = sifive_u54_prci_recalc_rate,
+};
+
+static ssize_t sifive_u54_pll_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sifive_u54_prci_driver *driver = dev_get_drvdata(dev);
+	return sprintf(buf, "%ld", clk_get_rate(driver->clks[0]));
+}
+
+static ssize_t sifive_u54_pll_rate_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct sifive_u54_prci_driver *driver = dev_get_drvdata(dev);
+	unsigned long rate;
+	char *endp;
+
+	rate = simple_strtoul(buf, &endp, 0);
+	if (*endp != 0 && *endp != '\n')
+		return -EINVAL;
+
+	clk_set_rate(driver->clks[0], rate);
+	return count;
+}
+
+static DEVICE_ATTR(rate, 0644, sifive_u54_pll_show, sifive_u54_pll_rate_store);
+
+static int sifive_u54_prci_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct clk_init_data init;
+	struct sifive_u54_prci_driver *driver;
+	struct resource *res;
+	const char *parent;
+	int i;
+
+	parent = of_clk_get_parent_name(dev->of_node, 0);
+	if (!parent) {
+		dev_err(dev, "No OF parent clocks found\n");
+		return -EINVAL;
+	}
+
+	driver = devm_kzalloc(dev, sizeof(*driver), GFP_KERNEL);
+	if (!driver) {
+		dev_err(dev, "Out of memory\n");
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	driver->reg = devm_ioremap_resource(dev, res);
+	if (IS_ERR(driver->reg))
+		return PTR_ERR(driver->reg);
+
+	/* Link the data structure */
+	driver->table.clk_num = PRCI_CLOCKS;
+	driver->table.clks = &driver->clks[0];
+	dev_set_drvdata(dev, driver);
+
+	/* Describe the clocks */
+	snprintf(driver->plls[CORE_CLOCK].name, NAME_LEN, "%s.core", dev->of_node->name);
+	driver->plls[CORE_CLOCK].freq = 0x4;
+	driver->plls[CORE_CLOCK].glcm = 0x24;
+	snprintf(driver->plls[GEMTX_CLOCK].name, NAME_LEN, "%s.gemtx", dev->of_node->name);
+	driver->plls[GEMTX_CLOCK].freq = 0x1c;
+	driver->plls[GEMTX_CLOCK].glcm = 0; /* None; cannot be set_rate */
+
+	/* Export the clocks */
+	for (i = 0; i < PRCI_CLOCKS; ++i) {
+		init.name = &driver->plls[i].name[0];
+		init.ops = driver->plls[i].glcm ? &sifive_u54_prci_ops_rw : &sifive_u54_prci_ops_ro;
+		init.num_parents = 1;
+		init.parent_names = &parent;
+		init.flags = 0;
+
+		driver->plls[i].driver = driver;
+		driver->plls[i].hw.init = &init;
+
+		driver->clks[i] = devm_clk_register(dev, &driver->plls[i].hw);
+		if (IS_ERR(driver->clks[i])) {
+			dev_err(dev, "Failed to register clock %d, %ld\n", i, PTR_ERR(driver->clks[i]));
+			return PTR_ERR(driver->clks[i]);
+		}
+	}
+
+	of_clk_add_provider(dev->of_node, of_clk_src_onecell_get, &driver->table);
+	device_create_file(dev, &dev_attr_rate);
+	dev_info(dev, "Registered U54 core clocks\n");
+
+	return 0;
+}
+
+static const struct of_device_id sifive_u54_prci_of_match[] = {
+	{ .compatible = "sifive,aloeprci0", },
+	{}
+};
+
+static struct platform_driver sifive_u54_prci_driver = {
+	.driver	= {
+		.name = "sifive-u54-prci",
+		.of_match_table = sifive_u54_prci_of_match,
+	},
+	.probe = sifive_u54_prci_probe,
+};
+
+static int __init sifive_u54_prci_init(void)
+{
+	return platform_driver_register(&sifive_u54_prci_driver);
+}
+core_initcall(sifive_u54_prci_init);
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 3f50526a771f..37b1c134a76c 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -469,6 +469,13 @@ config GPIO_SNPS_CREG
 	  where only several fields in register belong to GPIO lines and
 	  each GPIO line owns a field with different length and on/off value.
 
+config GPIO_SIFIVE
+	bool "SiFive GPIO support"
+	depends on OF_GPIO
+	select GPIOLIB_IRQCHIP
+	help
+	  Say yes here to support the GPIO device on SiFive SoCs.
+
 config GPIO_SPEAR_SPICS
 	bool "ST SPEAr13xx SPI Chip Select as GPIO support"
 	depends on PLAT_SPEAR
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 54d55274b93a..660e2e70f05c 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -114,6 +114,7 @@ obj-$(CONFIG_ARCH_SA1100)	+= gpio-sa1100.o
 obj-$(CONFIG_GPIO_SAMA5D2_PIOBU)	+= gpio-sama5d2-piobu.o
 obj-$(CONFIG_GPIO_SCH)		+= gpio-sch.o
 obj-$(CONFIG_GPIO_SCH311X)	+= gpio-sch311x.o
+obj-$(CONFIG_GPIO_SIFIVE)	+= gpio-sifive.o
 obj-$(CONFIG_GPIO_SNPS_CREG)	+= gpio-creg-snps.o
 obj-$(CONFIG_GPIO_SODAVILLE)	+= gpio-sodaville.o
 obj-$(CONFIG_GPIO_SPEAR_SPICS)	+= gpio-spear-spics.o
diff --git a/drivers/gpio/gpio-sifive.c b/drivers/gpio/gpio-sifive.c
new file mode 100644
index 000000000000..6482ebbc00ce
--- /dev/null
+++ b/drivers/gpio/gpio-sifive.c
@@ -0,0 +1,322 @@
+/*
+ * SiFive GPIO driver
+ *
+ * Copyright (C) 2018 SiFive, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/of_irq.h>
+#include <linux/gpio/driver.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+
+#define GPIO_INPUT_VAL	0x00
+#define GPIO_INPUT_EN	0x04
+#define GPIO_OUTPUT_EN	0x08
+#define GPIO_OUTPUT_VAL	0x0C
+#define GPIO_RISE_IE	0x18
+#define GPIO_RISE_IP	0x1C
+#define GPIO_FALL_IE	0x20
+#define GPIO_FALL_IP	0x24
+#define GPIO_HIGH_IE	0x28
+#define GPIO_HIGH_IP	0x2C
+#define GPIO_LOW_IE	0x30
+#define GPIO_LOW_IP	0x34
+#define GPIO_OUTPUT_XOR	0x40
+
+#define MAX_GPIO	32
+
+struct sifive_gpio {
+	raw_spinlock_t		lock;
+	void __iomem		*base;
+	struct gpio_chip	gc;
+	unsigned long		enabled;
+	unsigned		trigger[MAX_GPIO];
+	unsigned int		irq_parent[MAX_GPIO];
+	struct sifive_gpio	*self_ptr[MAX_GPIO];
+};
+
+static void sifive_assign_bit(void __iomem *ptr, int offset, int value)
+{
+	// It's frustrating that we are not allowed to use the device atomics
+	// which are GUARANTEED to be supported by this device on RISC-V
+	u32 bit = BIT(offset), old = ioread32(ptr);
+	if (value)
+		iowrite32(old | bit, ptr);
+	else
+		iowrite32(old & ~bit, ptr);
+}
+
+static int sifive_direction_input(struct gpio_chip *gc, unsigned offset)
+{
+	struct sifive_gpio *chip = gpiochip_get_data(gc);
+	unsigned long flags;
+
+	if (offset >= gc->ngpio)
+		return -EINVAL;
+
+	raw_spin_lock_irqsave(&chip->lock, flags);
+	sifive_assign_bit(chip->base + GPIO_OUTPUT_EN, offset, 0);
+	sifive_assign_bit(chip->base + GPIO_INPUT_EN,  offset, 1);
+	raw_spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int sifive_direction_output(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct sifive_gpio *chip = gpiochip_get_data(gc);
+	unsigned long flags;
+
+	if (offset >= gc->ngpio)
+		return -EINVAL;
+
+	raw_spin_lock_irqsave(&chip->lock, flags);
+	sifive_assign_bit(chip->base + GPIO_INPUT_EN,   offset, 0);
+	sifive_assign_bit(chip->base + GPIO_OUTPUT_VAL, offset, value);
+	sifive_assign_bit(chip->base + GPIO_OUTPUT_EN,  offset, 1);
+	raw_spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int sifive_get_direction(struct gpio_chip *gc, unsigned offset)
+{
+	struct sifive_gpio *chip = gpiochip_get_data(gc);
+
+	if (offset >= gc->ngpio)
+		return -EINVAL;
+
+	return !(ioread32(chip->base + GPIO_OUTPUT_EN) & BIT(offset));
+}
+
+static int sifive_get_value(struct gpio_chip *gc, unsigned offset)
+{
+	struct sifive_gpio *chip = gpiochip_get_data(gc);
+
+	if (offset >= gc->ngpio)
+		return -EINVAL;
+
+	return !!(ioread32(chip->base + GPIO_INPUT_VAL) & BIT(offset));
+}
+
+static void sifive_set_value(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct sifive_gpio *chip = gpiochip_get_data(gc);
+	unsigned long flags;
+
+	if (offset >= gc->ngpio)
+		return;
+
+	raw_spin_lock_irqsave(&chip->lock, flags);
+	sifive_assign_bit(chip->base + GPIO_OUTPUT_VAL, offset, value);
+	raw_spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+static void sifive_set_ie(struct sifive_gpio *chip, int offset)
+{
+	unsigned long flags;
+	unsigned trigger;
+
+	raw_spin_lock_irqsave(&chip->lock, flags);
+	trigger = (chip->enabled & BIT(offset)) ? chip->trigger[offset] : 0;
+	sifive_assign_bit(chip->base + GPIO_RISE_IE, offset, trigger & IRQ_TYPE_EDGE_RISING);
+	sifive_assign_bit(chip->base + GPIO_FALL_IE, offset, trigger & IRQ_TYPE_EDGE_FALLING);
+	sifive_assign_bit(chip->base + GPIO_HIGH_IE, offset, trigger & IRQ_TYPE_LEVEL_HIGH);
+	sifive_assign_bit(chip->base + GPIO_LOW_IE,  offset, trigger & IRQ_TYPE_LEVEL_LOW);
+	raw_spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+static int sifive_irq_set_type(struct irq_data *d, unsigned trigger)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct sifive_gpio *chip = gpiochip_get_data(gc);
+	int offset = irqd_to_hwirq(d);
+
+	if (offset < 0 || offset >= gc->ngpio)
+		return -EINVAL;
+
+	chip->trigger[offset] = trigger;
+	sifive_set_ie(chip, offset);
+	return 0;
+}
+
+/* chained_irq_{enter,exit} already mask the parent */
+static void sifive_irq_mask(struct irq_data *d) { }
+static void sifive_irq_unmask(struct irq_data *d) { }
+
+static void sifive_irq_enable(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct sifive_gpio *chip = gpiochip_get_data(gc);
+	int offset = irqd_to_hwirq(d) % MAX_GPIO; // must not fail
+	u32 bit = BIT(offset);
+
+	/* Switch to input */
+	sifive_direction_input(gc, offset);
+
+	/* Clear any sticky pending interrupts */
+	iowrite32(bit, chip->base + GPIO_RISE_IP);
+	iowrite32(bit, chip->base + GPIO_FALL_IP);
+	iowrite32(bit, chip->base + GPIO_HIGH_IP);
+	iowrite32(bit, chip->base + GPIO_LOW_IP);
+
+	/* Enable interrupts */
+	assign_bit(offset, &chip->enabled, 1);
+	sifive_set_ie(chip, offset);
+}
+
+static void sifive_irq_disable(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct sifive_gpio *chip = gpiochip_get_data(gc);
+	int offset = irqd_to_hwirq(d) % MAX_GPIO; // must not fail
+
+	assign_bit(offset, &chip->enabled, 0);
+	sifive_set_ie(chip, offset);
+}
+
+static struct irq_chip sifive_irqchip = {
+	.name		= "sifive-gpio",
+	.irq_set_type	= sifive_irq_set_type,
+	.irq_mask	= sifive_irq_mask,
+	.irq_unmask	= sifive_irq_unmask,
+	.irq_enable	= sifive_irq_enable,
+	.irq_disable	= sifive_irq_disable,
+};
+
+static void sifive_irq_handler(struct irq_desc *desc)
+{
+	struct irq_chip *irqchip = irq_desc_get_chip(desc);
+	struct sifive_gpio **self_ptr = irq_desc_get_handler_data(desc);
+	struct sifive_gpio *chip = *self_ptr;
+	int offset = self_ptr - &chip->self_ptr[0];
+	u32 bit = BIT(offset);
+
+	chained_irq_enter(irqchip, desc);
+
+	/* Re-arm the edge triggers so don't miss the next one */
+	iowrite32(bit, chip->base + GPIO_RISE_IP);
+	iowrite32(bit, chip->base + GPIO_FALL_IP);
+
+	generic_handle_irq(irq_find_mapping(chip->gc.irq.domain, offset));
+
+	/* Re-arm the level triggers after handling to prevent spurious refire */
+	iowrite32(bit, chip->base + GPIO_HIGH_IP);
+	iowrite32(bit, chip->base + GPIO_LOW_IP);
+
+	chained_irq_exit(irqchip, desc);
+}
+
+static int sifive_gpio_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = pdev->dev.of_node;
+	struct sifive_gpio *chip;
+	struct resource *res;
+	int gpio, irq, ret, ngpio;
+
+	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip) {
+		dev_err(dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	chip->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(chip->base)) {
+		dev_err(dev, "failed to allocate device memory\n");
+		return PTR_ERR(chip->base);
+	}
+
+	ngpio = of_irq_count(node);
+	if (ngpio >= MAX_GPIO) {
+		dev_err(dev, "too many interrupts\n");
+		return -EINVAL;
+	}
+
+	raw_spin_lock_init(&chip->lock);
+	chip->gc.direction_input = sifive_direction_input;
+	chip->gc.direction_output = sifive_direction_output;
+	chip->gc.get_direction = sifive_get_direction;
+	chip->gc.get = sifive_get_value;
+	chip->gc.set = sifive_set_value;
+	chip->gc.base = -1;
+	chip->gc.ngpio = ngpio;
+	chip->gc.label = dev_name(dev);
+	chip->gc.parent = dev;
+	chip->gc.owner = THIS_MODULE;
+
+	ret = gpiochip_add_data(&chip->gc, chip);
+	if (ret)
+		return ret;
+
+	/* Disable all GPIO interrupts before enabling parent interrupts */
+	iowrite32(0, chip->base + GPIO_RISE_IE);
+	iowrite32(0, chip->base + GPIO_FALL_IE);
+	iowrite32(0, chip->base + GPIO_HIGH_IE);
+	iowrite32(0, chip->base + GPIO_LOW_IE);
+	chip->enabled = 0;
+
+	ret = gpiochip_irqchip_add(&chip->gc, &sifive_irqchip, 0, handle_simple_irq, IRQ_TYPE_NONE);
+	if (ret) {
+		dev_err(dev, "could not add irqchip\n");
+		gpiochip_remove(&chip->gc);
+		return ret;
+	}
+
+	chip->gc.irq.num_parents = ngpio;
+	chip->gc.irq.parents = &chip->irq_parent[0];
+	chip->gc.irq.map = &chip->irq_parent[0];
+
+	for (gpio = 0; gpio < ngpio; ++gpio) {
+		irq = platform_get_irq(pdev, gpio);
+		if (irq < 0) {
+			dev_err(dev, "invalid IRQ\n");
+			gpiochip_remove(&chip->gc);
+			return -ENODEV;
+		}
+
+		chip->irq_parent[gpio] = irq;
+		chip->self_ptr[gpio] = chip;
+		chip->trigger[gpio] = IRQ_TYPE_LEVEL_HIGH;
+	}
+
+	for (gpio = 0; gpio < ngpio; ++gpio) {
+		irq = chip->irq_parent[gpio];
+		irq_set_chained_handler_and_data(irq, sifive_irq_handler, &chip->self_ptr[gpio]);
+		irq_set_parent(irq_find_mapping(chip->gc.irq.domain, gpio), irq);
+	}
+
+	platform_set_drvdata(pdev, chip);
+	dev_info(dev, "SiFive GPIO chip registered %d GPIOs\n", ngpio);
+
+	return 0;
+}
+
+static const struct of_device_id sifive_gpio_match[] = {
+	{
+		.compatible = "sifive,gpio0",
+	},
+	{ },
+};
+
+static struct platform_driver sifive_gpio_driver = {
+	.probe		= sifive_gpio_probe,
+	.driver = {
+		.name	= "sifive_gpio",
+		.of_match_table = of_match_ptr(sifive_gpio_match),
+	},
+};
+builtin_platform_driver(sifive_gpio_driver)
diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c
index fae147452aff..80479a90dc97 100644
--- a/drivers/mtd/spi-nor/spi-nor.c
+++ b/drivers/mtd/spi-nor/spi-nor.c
@@ -1460,6 +1460,45 @@ static int macronix_quad_enable(struct spi_nor *nor)
 	return 0;
 }
 
+/**
+ * issi_unlock() - clear BP[0123] write-protection.
+ * @nor:	pointer to a 'struct spi_nor'
+ *
+ * Bits [2345] of the Status Register are BP[0123].
+ * ISSI chips use a different block protection scheme than other chips.
+ * Just disable the write-protect unilaterally.
+ *
+ * Return: 0 on success, -errno otherwise.
+ */
+static int issi_unlock(struct spi_nor *nor)
+{
+	int ret, val;
+	u8 mask = SR_BP0 | SR_BP1 | SR_BP2 | SR_BP3;
+
+	val = read_sr(nor);
+	if (val < 0)
+		return val;
+	if (!(val & mask))
+		return 0;
+
+	write_enable(nor);
+
+	write_sr(nor, val & ~mask);
+
+	ret = spi_nor_wait_till_ready(nor);
+	if (ret)
+		return ret;
+
+	ret = read_sr(nor);
+	if (ret > 0 && !(ret & mask)) {
+		dev_info(nor->dev, "ISSI Block Protection Bits cleared\n");
+		return 0;
+	} else {
+		dev_err(nor->dev, "ISSI Block Protection Bits not cleared\n");
+		return -EINVAL;
+	}
+}
+
 /**
  * spansion_quad_enable() - set QE bit in Configuraiton Register.
  * @nor:	pointer to a 'struct spi_nor'
@@ -1834,6 +1873,9 @@ static const struct flash_info spi_nor_ids[] = {
 			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ "is25wp128",  INFO(0x9d7018, 0, 64 * 1024, 256,
 			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ "is25wp256d", INFO(0x9d7019, 0, 32 * 1024, 1024,
+	                SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)
+	},
 
 	/* Macronix */
 	{ "mx25l512e",   INFO(0xc22010, 0, 64 * 1024,   1, SECT_4K) },
@@ -3923,6 +3965,9 @@ static int spi_nor_init(struct spi_nor *nor)
 		spi_nor_wait_till_ready(nor);
 	}
 
+	if (JEDEC_MFR(nor->info) == SNOR_MFR_ISSI)
+		issi_unlock(nor);
+
 	if (nor->quad_enable) {
 		err = nor->quad_enable(nor);
 		if (err) {
@@ -4127,7 +4172,7 @@ int spi_nor_scan(struct spi_nor *nor, const char *name,
 	if (ret)
 		return ret;
 
-	if (nor->addr_width) {
+	if (nor->addr_width && JEDEC_MFR(info) != SNOR_MFR_ISSI) {
 		/* already configured from SFDP */
 	} else if (info->addr_width) {
 		nor->addr_width = info->addr_width;
diff --git a/drivers/net/phy/mdio_bus.c b/drivers/net/phy/mdio_bus.c
index 4be4cc09eb90..a69a95304cb3 100644
--- a/drivers/net/phy/mdio_bus.c
+++ b/drivers/net/phy/mdio_bus.c
@@ -57,9 +57,6 @@ static int mdiobus_register_gpiod(struct mdio_device *mdiodev)
 
 	mdiodev->reset = gpiod;
 
-	/* Assert the reset signal again */
-	mdio_device_reset(mdiodev, 1);
-
 	return 0;
 }
 
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index 54f8238aac0d..995b9f654d46 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -389,6 +389,16 @@ config PWM_SAMSUNG
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-samsung.
 
+config PWM_SIFIVE
+	tristate "SiFive PWM support"
+	depends on OF
+	depends on COMMON_CLK
+	help
+	  Generic PWM framework driver for SiFive SoCs.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-sifive.
+
 config PWM_SPEAR
 	tristate "STMicroelectronics SPEAr PWM support"
 	depends on PLAT_SPEAR
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index 448825e892bc..0da3e99b0186 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -38,6 +38,7 @@ obj-$(CONFIG_PWM_RCAR)		+= pwm-rcar.o
 obj-$(CONFIG_PWM_RENESAS_TPU)	+= pwm-renesas-tpu.o
 obj-$(CONFIG_PWM_ROCKCHIP)	+= pwm-rockchip.o
 obj-$(CONFIG_PWM_SAMSUNG)	+= pwm-samsung.o
+obj-$(CONFIG_PWM_SIFIVE)	+= pwm-sifive.o
 obj-$(CONFIG_PWM_SPEAR)		+= pwm-spear.o
 obj-$(CONFIG_PWM_STI)		+= pwm-sti.o
 obj-$(CONFIG_PWM_STM32)		+= pwm-stm32.o
diff --git a/drivers/pwm/pwm-sifive.c b/drivers/pwm/pwm-sifive.c
new file mode 100644
index 000000000000..93bc0844d23a
--- /dev/null
+++ b/drivers/pwm/pwm-sifive.c
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2018 SiFive, Inc
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2, as published by
+ * the Free Software Foundation.
+ */
+
+#include <dt-bindings/pwm/pwm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#define MAX_PWM			4
+
+/* Register offsets */
+#define REG_PWMCFG		0x0
+#define REG_PWMCOUNT		0x8
+#define REG_PWMS		0x10
+#define	REG_PWMCMP0		0x20
+
+/* PWMCFG fields */
+#define BIT_PWM_SCALE		0
+#define BIT_PWM_STICKY		8
+#define BIT_PWM_ZERO_ZMP	9
+#define BIT_PWM_DEGLITCH	10
+#define BIT_PWM_EN_ALWAYS	12
+#define BIT_PWM_EN_ONCE		13
+#define BIT_PWM0_CENTER		16
+#define BIT_PWM0_GANG		24
+#define BIT_PWM0_IP		28
+
+#define SIZE_PWMCMP		4
+#define MASK_PWM_SCALE		0xf
+
+struct sifive_pwm_device {
+	struct pwm_chip		chip;
+	struct notifier_block	notifier;
+	struct clk		*clk;
+	void __iomem		*regs;
+	int 			irq;
+	unsigned int		approx_period;
+	unsigned int		real_period;
+};
+
+static inline struct sifive_pwm_device *chip_to_sifive(struct pwm_chip *c)
+{
+	return container_of(c, struct sifive_pwm_device, chip);
+}
+
+static inline struct sifive_pwm_device *notifier_to_sifive(struct notifier_block *nb)
+{
+	return container_of(nb, struct sifive_pwm_device, notifier);
+}
+
+static int sifive_pwm_apply(struct pwm_chip *chip, struct pwm_device *dev, struct pwm_state *state)
+{
+	struct sifive_pwm_device *pwm = chip_to_sifive(chip);
+	unsigned int duty_cycle;
+	u32 frac;
+
+	duty_cycle = state->duty_cycle;
+	if (!state->enabled) duty_cycle = 0;
+	if (state->polarity == PWM_POLARITY_NORMAL) duty_cycle = state->period - duty_cycle;
+
+	frac = ((u64)duty_cycle << 16) / state->period;
+	frac = min(frac, 0xFFFFU);
+
+	iowrite32(frac, pwm->regs + REG_PWMCMP0 + (dev->hwpwm * SIZE_PWMCMP));
+
+	if (state->enabled) {
+		state->period = pwm->real_period;
+		state->duty_cycle = ((u64)frac * pwm->real_period) >> 16;
+		if (state->polarity == PWM_POLARITY_NORMAL)
+			state->duty_cycle = state->period - state->duty_cycle;
+	}
+
+	return 0;
+}
+
+static void sifive_pwm_get_state(struct pwm_chip *chip, struct pwm_device *dev, struct pwm_state *state)
+{
+	struct sifive_pwm_device *pwm = chip_to_sifive(chip);
+	unsigned long duty;
+
+	duty = ioread32(pwm->regs + REG_PWMCMP0 + (dev->hwpwm * SIZE_PWMCMP));
+
+	state->period     = pwm->real_period;
+	state->duty_cycle = ((u64)duty * pwm->real_period) >> 16;
+	state->polarity   = PWM_POLARITY_INVERSED;
+	state->enabled    = duty > 0;
+}
+
+static const struct pwm_ops sifive_pwm_ops = {
+	.get_state	= sifive_pwm_get_state,
+	.apply		= sifive_pwm_apply,
+	.owner		= THIS_MODULE,
+};
+
+static struct pwm_device *sifive_pwm_xlate(struct pwm_chip *chip, const struct of_phandle_args *args)
+{
+	struct sifive_pwm_device *pwm = chip_to_sifive(chip);
+	struct pwm_device *dev;
+
+	if (args->args[0] >= chip->npwm)
+		return ERR_PTR(-EINVAL);
+
+	dev = pwm_request_from_chip(chip, args->args[0], NULL);
+	if (IS_ERR(dev))
+		return dev;
+
+	/* The period cannot be changed on a per-PWM basis */
+	dev->args.period   = pwm->real_period;
+	dev->args.polarity = PWM_POLARITY_NORMAL;
+	if (args->args[1] & PWM_POLARITY_INVERTED)
+		dev->args.polarity = PWM_POLARITY_INVERSED;
+
+	return dev;
+}
+
+static void sifive_pwm_update_clock(struct sifive_pwm_device *pwm, unsigned long rate)
+{
+	/* (1 << (16+scale)) * 10^9/rate = real_period */
+	unsigned long scalePow = (pwm->approx_period * (u64)rate) / 1000000000;
+	int scale = ilog2(scalePow) - 16;
+
+	scale = clamp(scale, 0, 0xf);
+	iowrite32((1 << BIT_PWM_EN_ALWAYS) | (scale << BIT_PWM_SCALE), pwm->regs + REG_PWMCFG);
+
+	pwm->real_period = (1000000000ULL << (16 + scale)) / rate;
+}
+
+static int sifive_pwm_clock_notifier(struct notifier_block *nb, unsigned long event, void *data)
+{
+	struct clk_notifier_data *ndata = data;
+	struct sifive_pwm_device *pwm = notifier_to_sifive(nb);
+
+	if (event == POST_RATE_CHANGE)
+		sifive_pwm_update_clock(pwm, ndata->new_rate);
+
+	return NOTIFY_OK;
+}
+
+static int sifive_pwm_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = pdev->dev.of_node;
+	struct sifive_pwm_device *pwm;
+	struct pwm_chip *chip;
+	struct resource *res;
+	int ret;
+
+	pwm = devm_kzalloc(dev, sizeof(*pwm), GFP_KERNEL);
+	if (!pwm) {
+		dev_err(dev, "Out of memory\n");
+		return -ENOMEM;
+	}
+
+	chip = &pwm->chip;
+	chip->dev = dev;
+	chip->ops = &sifive_pwm_ops;
+	chip->of_xlate = sifive_pwm_xlate;
+	chip->of_pwm_n_cells = 2;
+	chip->base = -1;
+
+	ret = of_property_read_u32(node, "sifive,npwm", &chip->npwm);
+	if (ret < 0 || chip->npwm > MAX_PWM) chip->npwm = MAX_PWM;
+
+	ret = of_property_read_u32(node, "sifive,approx-period", &pwm->approx_period);
+	if (ret < 0) {
+		dev_err(dev, "Unable to read sifive,approx-period from DTS\n");
+		return -ENOENT;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pwm->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(pwm->regs)) {
+		dev_err(dev, "Unable to map IO resources\n");
+		return PTR_ERR(pwm->regs);
+	}
+
+	pwm->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(pwm->clk)) {
+		dev_err(dev, "Unable to find controller clock\n");
+		return PTR_ERR(pwm->clk);
+	}
+
+	pwm->irq = platform_get_irq(pdev, 0);
+	if (pwm->irq < 0) {
+		dev_err(dev, "Unable to find interrupt\n");
+		return pwm->irq;
+	}
+
+	/* Watch for changes to underlying clock frequency */
+	pwm->notifier.notifier_call = sifive_pwm_clock_notifier;
+	clk_notifier_register(pwm->clk, &pwm->notifier);
+
+	/* Initialize PWM config */
+	sifive_pwm_update_clock(pwm, clk_get_rate(pwm->clk));
+
+	/* No interrupt handler needed yet */
+/*
+	ret = devm_request_irq(dev, pwm->irq, sifive_pwm_irq, 0, dev_name(dev), pwm);
+	if (ret) {
+		dev_err(dev, "Unable to bind interrupt\n");
+		return ret;
+	}
+*/
+
+	ret = pwmchip_add(chip);
+	if (ret < 0) {
+		dev_err(dev, "cannot register PWM: %d\n", ret);
+		clk_notifier_unregister(pwm->clk, &pwm->notifier);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, pwm);
+	dev_info(dev, "SiFive PWM chip registered %d PWMs\n", chip->npwm);
+
+	return 0;
+}
+
+static int sifive_pwm_remove(struct platform_device *dev)
+{
+	struct sifive_pwm_device *pwm = platform_get_drvdata(dev);
+	struct pwm_chip *chip = &pwm->chip;
+
+	clk_notifier_unregister(pwm->clk, &pwm->notifier);
+	return pwmchip_remove(chip);
+}
+
+static const struct of_device_id sifive_pwm_of_match[] = {
+	{ .compatible = "sifive,pwm0" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sifive_pwm_of_match);
+
+static struct platform_driver sifive_pwm_driver = {
+	.probe = sifive_pwm_probe,
+	.remove = sifive_pwm_remove,
+	.driver = {
+		.name = "pwm-sifivem",
+		.of_match_table = of_match_ptr(sifive_pwm_of_match),
+	},
+};
+module_platform_driver(sifive_pwm_driver);
+
+MODULE_DESCRIPTION("SiFive PWM driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index f761655e2a36..b2e6b45035c4 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -848,6 +848,13 @@ config SPI_ZYNQMP_GQSPI
 	help
 	  Enables Xilinx GQSPI controller driver for Zynq UltraScale+ MPSoC.
 
+config SPI_SIFIVE
+        tristate "SiFive SPI controller"
+        depends on HAS_IOMEM
+	select SPI_BITBANG
+        help
+          This exposes the SPI controller IP from SiFive.
+
 #
 # Add new SPI master controllers in alphabetical order above this line
 #
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index d8fc03c9faa2..653d6e99ae63 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -119,6 +119,7 @@ obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
 obj-$(CONFIG_SPI_XLP)			+= spi-xlp.o
 obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
 obj-$(CONFIG_SPI_ZYNQMP_GQSPI)		+= spi-zynqmp-gqspi.o
+obj-$(CONFIG_SPI_SIFIVE)		+= spi-sifive.o
 
 # SPI slave protocol handlers
 obj-$(CONFIG_SPI_SLAVE_TIME)		+= spi-slave-time.o
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 72966bc0ac76..61732522fe3c 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1095,6 +1095,29 @@ config SERIAL_OMAP_CONSOLE
 	  your boot loader about how to pass options to the kernel at
 	  boot time.)
 
+config SERIAL_SIFIVE
+	tristate "SiFive UART support"
+	depends on OF
+	select SERIAL_CORE
+	help
+	  If you have a SiFive Freedom U500 or similar SoC, enable this to
+	  support the SiFive UART.
+
+config SERIAL_SIFIVE_CONSOLE
+	bool "Console on SiFive UART"
+	depends on SERIAL_SIFIVE=y
+	select SERIAL_CORE_CONSOLE
+	help
+	  Select this option if you would like to use a SiFive UART as the
+	  system console.
+
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/tty0) will still be used as the system console by default, but
+	  you can alter that using a kernel command line option such as
+	  "console=ttySIx". (Try "man bootparam" or see the documentation of
+	  your boot loader about how to pass options to the kernel at
+	  boot time.)
+
 config SERIAL_LANTIQ
 	bool "Lantiq serial driver"
 	depends on LANTIQ
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index 40b702aaa85e..adf1c34a0a18 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -91,6 +91,7 @@ obj-$(CONFIG_SERIAL_MVEBU_UART)	+= mvebu-uart.o
 obj-$(CONFIG_SERIAL_PIC32)	+= pic32_uart.o
 obj-$(CONFIG_SERIAL_MPS2_UART)	+= mps2-uart.o
 obj-$(CONFIG_SERIAL_OWL)	+= owl-uart.o
+obj-$(CONFIG_SERIAL_SIFIVE)	+= sifive.o
 obj-$(CONFIG_SERIAL_RDA)	+= rda-uart.o
 
 # GPIOLIB helpers for modem control lines
diff --git a/drivers/tty/serial/sifive.c b/drivers/tty/serial/sifive.c
new file mode 100644
index 000000000000..588fb31cc94d
--- /dev/null
+++ b/drivers/tty/serial/sifive.c
@@ -0,0 +1,1051 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * SiFive UART driver
+ * Copyright (C) 2018 Paul Walmsley <paul@pwsan.com>
+ *
+ * Based partially on drivers/tty/serial/pxa.c, drivers/pwm/pwm-sifive.c,
+ * and drivers/tty/serial/omap-serial.c
+ *
+ * See Chapter 19 "Universal Asynchronous Receiver/Transmitter (UART)" of
+ * SiFive FE310-G000 v2p3.
+ *
+ * The SiFive UART design is not 8250-compatible.  The following common
+ * features are not supported:
+ * - Word lengths other than 8 bits
+ * - Break handling
+ * - Parity
+ * - Flow control
+ * - Modem signals (DSR, RI, etc.)
+ * On the other hand, the design is free from the baggage of the classical 8250
+ * programming model.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/* XXX Magic SYSRQ support - is it possible to implement? */
+/* XXX ignore_status_mask */
+/* XXX Ensure operations are spinlocked that need to be spinlocked */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/serial_reg.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/serial_core.h>
+#include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+
+/*
+ * Register offsets
+ */
+
+/* TXDATA */
+#define SIFIVE_SERIAL_TXDATA_OFFS		0x0
+#define SIFIVE_SERIAL_TXDATA_FULL_SHIFT		31
+#define SIFIVE_SERIAL_TXDATA_FULL_MASK		(1 << SIFIVE_SERIAL_TXDATA_FULL_SHIFT)
+#define SIFIVE_SERIAL_TXDATA_DATA_SHIFT		0
+#define SIFIVE_SERIAL_TXDATA_DATA_MASK		(0xff << SIFIVE_SERIAL_TXDATA_DATA_SHIFT)
+
+/* RXDATA */
+#define SIFIVE_SERIAL_RXDATA_OFFS		0x4
+#define SIFIVE_SERIAL_RXDATA_EMPTY_SHIFT	31
+#define SIFIVE_SERIAL_RXDATA_EMPTY_MASK		(1 << SIFIVE_SERIAL_RXDATA_EMPTY_SHIFT)
+#define SIFIVE_SERIAL_RXDATA_DATA_SHIFT		0
+#define SIFIVE_SERIAL_RXDATA_DATA_MASK		(0xff << SIFIVE_SERIAL_RXDATA_DATA_SHIFT)
+
+/* TXCTRL */
+#define SIFIVE_SERIAL_TXCTRL_OFFS		0x8
+#define SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT	16
+#define SIFIVE_SERIAL_TXCTRL_TXCNT_MASK		(0x7 << SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT)
+#define SIFIVE_SERIAL_TXCTRL_NSTOP_SHIFT	1
+#define SIFIVE_SERIAL_TXCTRL_NSTOP_MASK		(1 << SIFIVE_SERIAL_TXCTRL_NSTOP_SHIFT)
+#define SIFIVE_SERIAL_TXCTRL_TXEN_SHIFT		0
+#define SIFIVE_SERIAL_TXCTRL_TXEN_MASK		(1 << SIFIVE_SERIAL_TXCTRL_TXEN_SHIFT)
+
+/* RXCTRL */
+#define SIFIVE_SERIAL_RXCTRL_OFFS		0xC
+#define SIFIVE_SERIAL_RXCTRL_RXCNT_SHIFT	16
+#define SIFIVE_SERIAL_RXCTRL_RXCNT_MASK		(0x7 << SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT)
+#define SIFIVE_SERIAL_RXCTRL_RXEN_SHIFT		0
+#define SIFIVE_SERIAL_RXCTRL_RXEN_MASK		(1 << SIFIVE_SERIAL_RXCTRL_RXEN_SHIFT)
+
+/* IE */
+#define SIFIVE_SERIAL_IE_OFFS			0x10
+#define SIFIVE_SERIAL_IE_RXWM_SHIFT		1
+#define SIFIVE_SERIAL_IE_RXWM_MASK		(1 << SIFIVE_SERIAL_IE_RXWM_SHIFT)
+#define SIFIVE_SERIAL_IE_TXWM_SHIFT		0
+#define SIFIVE_SERIAL_IE_TXWM_MASK		(1 << SIFIVE_SERIAL_IE_TXWM_SHIFT)
+
+/* IP */
+#define SIFIVE_SERIAL_IP_OFFS			0x14
+#define SIFIVE_SERIAL_IP_RXWM_SHIFT		1
+#define SIFIVE_SERIAL_IP_RXWM_MASK		(1 << SIFIVE_SERIAL_IP_RXWM_SHIFT)
+#define SIFIVE_SERIAL_IP_TXWM_SHIFT		0
+#define SIFIVE_SERIAL_IP_TXWM_MASK		(1 << SIFIVE_SERIAL_IP_TXWM_SHIFT)
+
+/* DIV */
+#define SIFIVE_SERIAL_DIV_OFFS			0x18
+#define SIFIVE_SERIAL_DIV_DIV_SHIFT		0
+#define SIFIVE_SERIAL_DIV_DIV_MASK		(0xffff << SIFIVE_SERIAL_IP_DIV_SHIFT)
+
+/*
+ * Config macros
+ */
+
+/* SIFIVE_SERIAL_MAX_PORTS: maximum number of UARTs possible on a device */
+/* XXX Move to Kconfig? */
+#define SIFIVE_SERIAL_MAX_PORTS			10
+
+/* SIFIVE_SERIAL_NAME: our driver's name that we pass to the operating system */
+#define SIFIVE_SERIAL_NAME			"sifive-serial"
+
+/* SIFIVE_TTY_PREFIX: tty name prefix for SiFive serial ports */
+#define SIFIVE_TTY_PREFIX			"ttySI"
+
+/*
+ *
+ */
+
+/**
+ * sifive_serial_port - driver-specific data extension to struct uart_port
+ * @port: struct uart_port embedded in this struct
+ * @dev: struct device *
+ * @ier: shadowed copy of the interrupt enable register
+ * @clkin_rate: input clock to the UART IP block.
+ * @bit_rate: UART serial line rate (e.g., 115200 bps)
+ * @clk_notifier: clock rate change notifier for upstream clock changes
+ */
+struct sifive_serial_port {
+	struct uart_port	port;
+	struct device		*dev;
+	unsigned char		ier;
+	unsigned long		clkin_rate;
+	unsigned long		bit_rate;
+	struct clk		*clk;
+	struct notifier_block	clk_notifier;
+};
+
+/*
+ * Structure container-of macros
+ */
+
+#define port_to_sifive_serial_port(p) (container_of((p), \
+						    struct sifive_serial_port, \
+						    port))
+
+#define notifier_to_sifive_serial_port(nb) (container_of((nb), \
+							 struct sifive_serial_port, \
+							 clk_notifier))
+
+/*
+ * Forward declarations
+ */
+static void sifive_serial_stop_tx(struct uart_port *port);
+
+/*
+ * Internal functions
+ */
+
+/**
+ * sifive_serial_early_write() - write to a UART register (early)
+ * @port: pointer to a struct uart_port record
+ * @offs: register address offset from the IP block base address
+ * @v: value to write to the register
+ *
+ * Given a pointer @port to a struct uart_port record, write the value @v to the
+ * IP block register address offset @offs.  This function is intended for early
+ * console use.
+ */
+static void sifive_serial_early_write(struct uart_port *port, u16 offs, u32 v)
+{
+	writel(v, port->membase + offs);
+}
+
+/**
+ * sifive_serial_early_read() - read from a UART register (early)
+ * @port: pointer to a struct uart_port record
+ * @offs: register address offset from the IP block base address
+ *
+ * Given a pointer @port to a struct uart_port record, read the contents of the
+ * IP block register located at offset @offs from the IP block base and return
+ * it.  This function is intended for early console use.
+ *
+ * Returns: the register value read from the UART.
+ */
+static u32 sifive_serial_early_read(struct uart_port *port, u16 offs)
+{
+	return readl(port->membase + offs);
+}
+
+/**
+ * sifive_serial_write() - write to a UART register
+ * @ssp: pointer to a struct sifive_serial_port record
+ * @offs: register address offset from the IP block base address
+ * @v: value to write to the register
+ *
+ * Write the value @v to the IP block register located at offset @offs from the
+ * IP block base, given a pointer @ssp to a struct sifive_serial_port record.
+ */
+static void sifive_serial_write(struct sifive_serial_port *ssp, u16 offs, u32 v)
+{
+	sifive_serial_early_write(&ssp->port, offs, v);
+}
+
+/**
+ * sifive_serial_read() - read from a UART register
+ * @ssp: pointer to a struct sifive_serial_port record
+ * @offs: register address offset from the IP block base address
+ *
+ * Read the contents of the IP block register located at offset @offs from the
+ * IP block base, given a pointer @ssp to a struct sifive_serial_port record.
+ *
+ * Returns: the value of the UART register
+ */
+static u32 sifive_serial_read(struct sifive_serial_port *ssp, u16 offs)
+{
+	return sifive_serial_early_read(&ssp->port, offs);
+}
+
+/**
+ * sifive_serial_is_txfifo_full() - is the TXFIFO full?
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Read the transmit FIFO "full" bit, returning a non-zero value if the
+ * TX FIFO is full, or zero if space remains.  Intended to be used to prevent
+ * writes to the TX FIFO when it's full.
+ *
+ * Returns: SIFIVE_SERIAL_TXDATA_FULL_MASK (non-zero) if the transmit FIFO
+ * is full, or 0 if space remains.
+ */
+static int sifive_serial_is_txfifo_full(struct sifive_serial_port *ssp)
+{
+	return sifive_serial_read(ssp, SIFIVE_SERIAL_TXDATA_OFFS) &
+		SIFIVE_SERIAL_TXDATA_FULL_MASK;
+}
+
+/**
+ * sifive_serial_transmit_char() - enqueue a byte to transmit onto the TX FIFO
+ * @ssp: pointer to a struct sifive_serial_port
+ * @ch: character to transmit
+ *
+ * Enqueue a byte @ch onto the transmit FIFO, given a pointer @ssp to the
+ * struct sifive_serial_port * to transmit on.  Caller should first check to
+ * ensure that the TXFIFO has space; see sifive_serial_is_txfifo_full().
+ */
+static void sifive_serial_transmit_char(struct sifive_serial_port *ssp, int ch)
+{
+	sifive_serial_write(ssp, SIFIVE_SERIAL_TXDATA_OFFS, ch);
+}
+
+/**
+ * sifive_serial_transmit_chars() - enqueue multiple bytes onto the TX FIFO
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Transfer up to a TX FIFO size's worth of characters from the Linux serial
+ * transmit buffer to the SiFive UART TX FIFO.
+ */
+static void sifive_serial_transmit_chars(struct sifive_serial_port *ssp)
+{
+	struct circ_buf *xmit = &ssp->port.state->xmit;
+	int count;
+
+	if (ssp->port.x_char) {
+		sifive_serial_transmit_char(ssp, ssp->port.x_char);
+		ssp->port.icount.tx++;
+		ssp->port.x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&ssp->port)) {
+		sifive_serial_stop_tx(&ssp->port);
+		return;
+	}
+	count = ssp->port.fifosize;
+	do {
+		sifive_serial_transmit_char(ssp, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		ssp->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&ssp->port);
+
+	if (uart_circ_empty(xmit))
+		sifive_serial_stop_tx(&ssp->port);
+}
+
+/**
+ * sifive_serial_enable_txwm() - enable transmit watermark interrupts
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Enable interrupt generation when the transmit FIFO watermark is reached
+ * on the UART referred to by @ssp.
+ */
+static void sifive_serial_enable_txwm(struct sifive_serial_port *ssp)
+{
+	if (ssp->ier & SIFIVE_SERIAL_IE_TXWM_MASK)
+		return;
+
+	ssp->ier |= SIFIVE_SERIAL_IE_TXWM_MASK;
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, ssp->ier);
+}
+
+/**
+ * sifive_serial_enable_rxwm() - enable receive watermark interrupts
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Enable interrupt generation when the receive FIFO watermark is reached
+ * on the UART referred to by @ssp.
+ */
+static void sifive_serial_enable_rxwm(struct sifive_serial_port *ssp)
+{
+	if (ssp->ier & SIFIVE_SERIAL_IE_RXWM_MASK)
+		return;
+
+	ssp->ier |= SIFIVE_SERIAL_IE_RXWM_MASK;
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, ssp->ier);
+}
+
+/**
+ * sifive_serial_disable_txwm() - disable transmit watermark interrupts
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Disable interrupt generation when the transmit FIFO watermark is reached
+ * on the UART referred to by @ssp.
+ */
+static void sifive_serial_disable_txwm(struct sifive_serial_port *ssp)
+{
+	if (!(ssp->ier & SIFIVE_SERIAL_IE_TXWM_MASK))
+		return;
+
+	ssp->ier &= ~SIFIVE_SERIAL_IE_TXWM_MASK;
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, ssp->ier);
+}
+
+/**
+ * sifive_serial_disable_rxwm() - disable receive watermark interrupts
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Disable interrupt generation when the receive FIFO watermark is reached
+ * on the UART referred to by @ssp.
+ */
+static void sifive_serial_disable_rxwm(struct sifive_serial_port *ssp)
+{
+	if (!(ssp->ier & SIFIVE_SERIAL_IE_RXWM_MASK))
+		return;
+
+	ssp->ier &= ~SIFIVE_SERIAL_IE_RXWM_MASK;
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, ssp->ier);
+}
+
+/**
+ * sifive_serial_receive_char() - receive a byte from the UART
+ * @ssp: pointer to a struct sifive_serial_port
+ * @is_empty: char pointer to return whether the RX FIFO is empty
+ *
+ * Try to read a byte from the SiFive UART RX FIFO, referenced by
+ * @ssp, and to return it.  Also returns the RX FIFO empty bit in
+ * the char pointed to by @ch.  The caller must pass the byte back to the
+ * Linux serial layer if needed.
+ *
+ * Returns: the byte read from the UART RX FIFO.
+ */
+static char sifive_serial_receive_char(struct sifive_serial_port *ssp,
+				       char *is_empty)
+{
+	u32 v;
+	u8 ch;
+
+	v = sifive_serial_read(ssp, SIFIVE_SERIAL_RXDATA_OFFS);
+
+	if (!is_empty)
+		WARN_ON(1);
+	else
+		*is_empty = (v & SIFIVE_SERIAL_RXDATA_EMPTY_MASK) >>
+			SIFIVE_SERIAL_RXDATA_EMPTY_SHIFT;
+
+	ch = (v & SIFIVE_SERIAL_RXDATA_DATA_MASK) >>
+		SIFIVE_SERIAL_RXDATA_DATA_SHIFT;
+
+	return ch;
+}
+
+/**
+ * sifive_serial_receive_chars() - receive multiple bytes from the UART
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Receive up to an RX FIFO's worth of bytes from the SiFive UART referred
+ * to by @ssp and pass them up to the Linux serial layer.
+ */
+static void sifive_serial_receive_chars(struct sifive_serial_port *ssp)
+{
+	unsigned char ch;
+	char is_empty;
+	int c;
+
+	for (c = ssp->port.fifosize; c > 0; --c) {
+		ch = sifive_serial_receive_char(ssp, &is_empty);
+		if (is_empty) break;
+
+		ssp->port.icount.rx++;
+		uart_insert_char(&ssp->port, 0, 0, ch, TTY_NORMAL);
+	}
+}
+
+/**
+ * sifive_serial_update_div() - calculate the divisor setting by the line rate
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Calculate the appropriate value of the clock divisor for the UART
+ * referred to by @ssp and the target line rate referred to by @bps, and
+ * return it.
+ */
+static void sifive_serial_update_div(struct sifive_serial_port *ssp)
+{
+	u16 div = DIV_ROUND_UP(ssp->clkin_rate, ssp->bit_rate) - 1;
+	/* XXX check for div out of spec */
+	sifive_serial_write(ssp, SIFIVE_SERIAL_DIV_OFFS, div);
+}
+
+/**
+ * sifive_serial_update_bit_rate() - set the UART "baud rate"
+ * @ssp: pointer to a struct sifive_serial_port
+ * @rate: new target bit rate
+ *
+ * Calculate the UART divisor value for the target bit rate @rate for the
+ * SiFive UART described by @ssp and program it into the UART.  There may
+ * be some error between the target bit rate and the actual bit rate implemented
+ * by the UART due to clock ratio granularity.
+ */
+static void sifive_serial_update_bit_rate(struct sifive_serial_port *ssp,
+					  unsigned int rate)
+{
+	if (ssp->bit_rate == rate)
+		return;
+
+	ssp->bit_rate = rate;
+	sifive_serial_update_div(ssp);
+}
+
+/**
+ * sifive_serial_set_stop_bits() - set the number of stop bits
+ * @ssp: pointer to a struct sifive_serial_port
+ * @nstop: 1 or 2 (stop bits)
+ *
+ * Program the SiFive UART referred to by @ssp to use @nstop stop bits.
+ */
+static void sifive_serial_set_stop_bits(struct sifive_serial_port *ssp,
+					char nstop)
+{
+	u32 v;
+
+	if (nstop < 1 || nstop > 2) {
+		WARN_ON(1);
+		return;
+	}
+
+	v = sifive_serial_read(ssp, SIFIVE_SERIAL_TXCTRL_OFFS);
+	v &= ~SIFIVE_SERIAL_TXCTRL_NSTOP_MASK;
+	v |= (nstop-1) << SIFIVE_SERIAL_TXCTRL_NSTOP_SHIFT;
+	sifive_serial_write(ssp, SIFIVE_SERIAL_TXCTRL_OFFS, v);
+}
+
+/**
+ * sifive_serial_wait_for_xmitr() - wait for an empty slot on the TX FIFO
+ * @ssp: pointer to a struct sifive_serial_port
+ *
+ * Delay while the UART TX FIFO referred to by @ssp is marked as full.
+ *
+ * XXX Probably should use a timeout/bailout.
+ */
+static inline void sifive_serial_wait_for_xmitr(struct sifive_serial_port *ssp)
+{
+	while (sifive_serial_is_txfifo_full(ssp))
+		udelay(1); /* XXX Should vary by bps rate */
+}
+
+/*
+ * Linux serial API functions
+ */
+
+static void sifive_serial_stop_tx(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_disable_txwm(ssp);
+}
+
+static void sifive_serial_stop_rx(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_disable_rxwm(ssp);
+}
+
+static void sifive_serial_start_tx(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_enable_txwm(ssp);
+}
+
+static irqreturn_t sifive_serial_irq(int irq, void *dev_id)
+{
+	struct sifive_serial_port *ssp = dev_id;
+	irqreturn_t r = IRQ_NONE;
+	int c = ssp->port.fifosize;
+	u32 ip;
+
+	spin_lock(&ssp->port.lock);
+
+	do {
+		ip = sifive_serial_read(ssp, SIFIVE_SERIAL_IP_OFFS);
+		if (!ip)
+			break;
+
+		r = IRQ_HANDLED;
+
+		if (ip & SIFIVE_SERIAL_IP_RXWM_MASK)
+			sifive_serial_receive_chars(ssp);
+		if (ip & SIFIVE_SERIAL_IP_TXWM_MASK)
+			sifive_serial_transmit_chars(ssp);
+	} while (c--);
+
+	spin_unlock(&ssp->port.lock);
+
+	tty_flip_buffer_push(&ssp->port.state->port);
+
+	return r;
+}
+
+static unsigned int sifive_serial_tx_empty(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	return !sifive_serial_is_txfifo_full(ssp);
+}
+
+static unsigned int sifive_serial_get_mctrl(struct uart_port *port)
+{
+	return 0; /* XXX -EINVAL? */
+}
+
+static void sifive_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	// dev_err(port->dev, "set_mctrl not supported\n");
+}
+
+static void sifive_serial_break_ctl(struct uart_port *port, int break_state)
+{
+	dev_err(port->dev, "sending break not supported\n");
+}
+
+static int sifive_serial_startup(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_enable_rxwm(ssp);
+
+	return 0;
+}
+
+static void sifive_serial_shutdown(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_disable_rxwm(ssp);
+	sifive_serial_disable_txwm(ssp);
+}
+
+/**
+ * sifive_serial_clk_notifier() - clock post-rate-change notifier
+ * @nb: pointer to the struct notifier_block, from the notifier code
+ * @event: event mask from the notifier code
+ * @data: pointer to the struct clk_notifier_data from the notifier code
+ *
+ * On the H5U SoC, the UART IP block is derived from the CPU clock source
+ * after a synchronous divide-by-two divider, so any CPU clock rate change
+ * requires the UART baud rate to be updated.  This presumably could corrupt any
+ * serial word currently being transmitted or received.  It would probably
+ * be better to stop receives and transmits, then complete the baud rate
+ * change, then re-enable them.
+ */
+static int sifive_serial_clk_notifier(struct notifier_block *nb,
+				      unsigned long event, void *data)
+{
+	struct clk_notifier_data *cnd = data;
+	struct sifive_serial_port *ssp = notifier_to_sifive_serial_port(nb);
+
+	if (event == POST_RATE_CHANGE && ssp->clkin_rate != cnd->new_rate) {
+		ssp->clkin_rate = cnd->new_rate;
+		sifive_serial_update_div(ssp);
+	}
+
+	return NOTIFY_OK;
+}
+
+static void sifive_serial_set_termios(struct uart_port *port,
+				      struct ktermios *termios,
+				      struct ktermios *old)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+	int rate;
+	char nstop;
+
+	if ((termios->c_cflag & CSIZE) != CS8) {
+		dev_err(ssp->port.dev, "only 8-bit words supported\n");
+		return;
+	}
+
+	/* Set number of stop bits */
+	nstop = (termios->c_cflag & CSTOPB) ? 2 : 1;
+	sifive_serial_set_stop_bits(ssp, nstop);
+
+	/* Set line rate */
+	rate = uart_get_baud_rate(port, termios, old, 0, ssp->clkin_rate / 16);
+	sifive_serial_update_bit_rate(ssp, rate);
+
+	/* XXX Enable FIFOs with watermark 1 */
+
+#if 0
+	spin_lock_irqsave(&ssp->port.lock, flags);
+#endif
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, rate);
+
+	/* XXX */
+	ssp->port.read_status_mask = 0;
+	if (termios->c_iflag & INPCK) {
+		dev_err(ssp->port.dev, "INPCK flag not supported\n");
+		return;
+	}
+	if (termios->c_iflag & (BRKINT | PARMRK)) {
+		dev_err(ssp->port.dev, "BRKINT/PARMRK flag not supported\n");
+		return;
+	}
+
+#if 0
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		ssp->port.ignore_status_mask |= UART_LSR_DR;
+#endif
+
+	/* XXX enable interrupts */
+}
+
+static void sifive_serial_release_port(struct uart_port *port)
+{
+}
+
+static int sifive_serial_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void sifive_serial_config_port(struct uart_port *port, int flags)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	ssp->port.type = PORT_SIFIVE_H5U;
+}
+
+static int sifive_serial_verify_port(struct uart_port *port,
+				     struct serial_struct *ser)
+{
+	return -EINVAL;
+}
+
+static const char *sifive_serial_type(struct uart_port *port)
+{
+	return port->type == PORT_SIFIVE_H5U ? SIFIVE_SERIAL_NAME : NULL;
+}
+
+/*
+ * Polling support
+ */
+
+#ifdef CONFIG_CONSOLE_POLL
+
+static void sifive_serial_poll_put_char(struct uart_port *port,
+					unsigned char ch)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_wait_for_xmitr(ssp);
+	sifive_serial_write(ssp, SIFIVE_SERIAL_TXDATA_OFFS, ch);
+}
+
+static int sifive_serial_poll_get_char(struct uart_port *port)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+	char is_empty, ch;
+
+	ch = sifive_serial_receive_char(ssp, &is_empty);
+	if (is_empty)
+		return NO_POLL_CHAR;
+
+	return ch;
+}
+
+#endif /* CONFIG_CONSOLE_POLL */
+
+/*
+ * Earlyconsole support
+ */
+
+#ifdef CONFIG_SERIAL_EARLYCON
+static void early_sifive_serial_putc(struct uart_port *port, int c)
+{
+	while (sifive_serial_early_read(port, SIFIVE_SERIAL_TXDATA_OFFS) &
+	       SIFIVE_SERIAL_TXDATA_FULL_MASK)
+		cpu_relax();
+
+	sifive_serial_early_write(port, SIFIVE_SERIAL_TXDATA_OFFS, c);
+}
+
+void early_sifive_serial_write(struct console *console, const char *s,
+			       unsigned int count)
+{
+	struct earlycon_device *device = console->data;
+	struct uart_port *port = &device->port;
+
+	uart_console_write(port, s, count, early_sifive_serial_putc);
+}
+
+static int __init early_sifive_serial_setup(struct earlycon_device *device,
+					    const char *options)
+{
+	struct uart_port *port = &device->port;
+
+	if (!(port->membase || port->iobase))
+		return -ENODEV;
+
+	device->con->write = early_sifive_serial_write;
+	return 0;
+}
+
+OF_EARLYCON_DECLARE(sifive, "sifive,freedom-uart", early_sifive_serial_setup);
+#endif /* CONFIG_SERIAL_EARLYCON */
+
+/*
+ * Linux console interface
+ */
+
+#ifdef CONFIG_SERIAL_SIFIVE_CONSOLE
+
+static struct sifive_serial_port *sifive_serial_console_ports[SIFIVE_SERIAL_MAX_PORTS];
+
+static void sifive_serial_console_putchar(struct uart_port *port, int ch)
+{
+	struct sifive_serial_port *ssp = port_to_sifive_serial_port(port);
+
+	sifive_serial_wait_for_xmitr(ssp);
+	sifive_serial_transmit_char(ssp, ch);
+}
+
+static void sifive_serial_console_write(struct console *co, const char *s,
+					unsigned int count)
+{
+	struct sifive_serial_port *ssp = sifive_serial_console_ports[co->index];
+	unsigned long flags;
+	unsigned int ier;
+	int locked = 1;
+
+	if (!ssp) return;
+
+	local_irq_save(flags);
+	if (ssp->port.sysrq)
+		locked = 0;
+	else if (oops_in_progress)
+		locked = spin_trylock(&ssp->port.lock);
+	else
+		spin_lock(&ssp->port.lock);
+
+	ier = sifive_serial_read(ssp, SIFIVE_SERIAL_IE_OFFS);
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, 0);
+
+	uart_console_write(&ssp->port, s, count, sifive_serial_console_putchar);
+
+	sifive_serial_write(ssp, SIFIVE_SERIAL_IE_OFFS, ier);
+
+	if (locked)
+		spin_unlock(&ssp->port.lock);
+	local_irq_restore(flags);
+}
+
+static int __init sifive_serial_console_setup(struct console *co, char *options)
+{
+	struct sifive_serial_port *ssp;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	ssp = sifive_serial_console_ports[co->index];
+	if (!ssp)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(&ssp->port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver sifive_serial_uart_driver;
+
+static struct console sifive_serial_console = {
+	.name		= SIFIVE_TTY_PREFIX,
+	.write		= sifive_serial_console_write,
+	.device		= uart_console_device,
+	.setup		= sifive_serial_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &sifive_serial_uart_driver,
+};
+
+static void sifive_serial_add_console_port(struct sifive_serial_port *ssp)
+{
+	sifive_serial_console_ports[ssp->port.line] = ssp;
+}
+
+static void sifive_serial_remove_console_port(struct sifive_serial_port *ssp)
+{
+	sifive_serial_console_ports[ssp->port.line] = 0;
+}
+
+#define SIFIVE_SERIAL_CONSOLE	(&sifive_serial_console)
+
+#else
+
+#define SIFIVE_SERIAL_CONSOLE	NULL
+
+static inline void sifive_serial_add_console_port(struct sifive_serial_port *ssp)
+{}
+static void sifive_serial_remove_console_port(struct sifive_serial_port *ssp)
+{}
+
+#endif
+
+static const struct uart_ops sifive_serial_uops = {
+	.tx_empty	= sifive_serial_tx_empty,
+	.set_mctrl	= sifive_serial_set_mctrl,
+	.get_mctrl	= sifive_serial_get_mctrl,
+	.stop_tx	= sifive_serial_stop_tx,
+	.start_tx	= sifive_serial_start_tx,
+	.stop_rx	= sifive_serial_stop_rx,
+	.break_ctl	= sifive_serial_break_ctl,
+	.startup	= sifive_serial_startup,
+	.shutdown	= sifive_serial_shutdown,
+	.set_termios	= sifive_serial_set_termios,
+	.type		= sifive_serial_type,
+	.release_port	= sifive_serial_release_port,
+	.request_port	= sifive_serial_request_port,
+	.config_port	= sifive_serial_config_port,
+	.verify_port	= sifive_serial_verify_port,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_put_char  = sifive_serial_poll_put_char,
+	.poll_get_char  = sifive_serial_poll_get_char,
+#endif
+};
+
+static struct uart_driver sifive_serial_uart_driver = {
+	.owner		= THIS_MODULE,
+	.driver_name	= SIFIVE_SERIAL_NAME,
+	.dev_name	= "ttySI",
+	.nr		= SIFIVE_SERIAL_MAX_PORTS,
+	.cons		= SIFIVE_SERIAL_CONSOLE,
+};
+
+static int sifive_serial_probe(struct platform_device *pdev)
+{
+	struct sifive_serial_port *ssp;
+	struct resource *mem;
+	struct clk *clk;
+	void __iomem *base;
+	int irq, id, r;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "could not acquire interrupt\n");
+		return -EPROBE_DEFER;
+	}
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(base)) {
+		dev_err(&pdev->dev, "could not acquire device memory\n");
+		return PTR_ERR(base);
+	}
+
+	clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "unable to find controller clock\n");
+		return PTR_ERR(clk);
+	}
+
+	id = of_alias_get_id(pdev->dev.of_node, "serial");
+	if (id < 0) {
+		dev_err(&pdev->dev, "missing aliases entry\n");
+		return id;
+	}
+
+#ifdef CONFIG_SERIAL_SIFIVE_CONSOLE
+	if (id > SIFIVE_SERIAL_MAX_PORTS) {
+		dev_err(&pdev->dev, "too many UARTs (%d)\n", id);
+		return -EINVAL;
+	}
+#endif
+
+	ssp = devm_kzalloc(&pdev->dev, sizeof(*ssp), GFP_KERNEL);
+	if (!ssp)
+		return -ENOMEM;
+
+	ssp->port.dev = &pdev->dev;
+	ssp->port.type = PORT_SIFIVE_H5U;
+	ssp->port.iotype = UPIO_MEM;
+	ssp->port.irq = irq;
+	ssp->port.fifosize = 8;
+	ssp->port.ops = &sifive_serial_uops;
+	ssp->port.line = id;
+	ssp->port.mapbase = mem->start;
+	ssp->port.membase = base;
+	ssp->dev = &pdev->dev;
+	ssp->clk = clk;
+	ssp->clk_notifier.notifier_call = sifive_serial_clk_notifier;
+
+	r = clk_notifier_register(ssp->clk, &ssp->clk_notifier);
+	if (r) {
+		dev_err(&pdev->dev, "could not register clock notifier: %d\n",
+			r);
+		goto probe_out1;
+	}
+
+	/* Setup clock divider */
+	ssp->clkin_rate = clk_get_rate(ssp->clk);
+	ssp->bit_rate = 115200;
+	sifive_serial_update_div(ssp);
+
+	platform_set_drvdata(pdev, ssp);
+
+	/* Enable transmits and set the watermark level to 1 */
+	sifive_serial_write(ssp, SIFIVE_SERIAL_TXCTRL_OFFS,
+			    (1 << SIFIVE_SERIAL_TXCTRL_TXCNT_SHIFT) |
+			    SIFIVE_SERIAL_TXCTRL_TXEN_MASK);
+
+	/* Enable receives and set the watermark level to 0 */
+	sifive_serial_write(ssp, SIFIVE_SERIAL_RXCTRL_OFFS,
+			    (0 << SIFIVE_SERIAL_RXCTRL_RXCNT_SHIFT) |
+			    SIFIVE_SERIAL_RXCTRL_RXEN_MASK);
+
+	r = request_irq(ssp->port.irq, sifive_serial_irq, ssp->port.irqflags,
+			dev_name(&pdev->dev), ssp);
+	if (r) {
+		dev_err(&pdev->dev, "could not attach interrupt: %d\n", r);
+		goto probe_out2;
+	}
+
+	r = uart_add_one_port(&sifive_serial_uart_driver, &ssp->port);
+	if (r != 0) {
+		dev_err(&pdev->dev, "could not add uart: %d\n", r);
+		goto probe_out3;
+	}
+
+	sifive_serial_add_console_port(ssp);
+
+	return 0;
+
+probe_out3:
+	free_irq(ssp->port.irq, ssp);
+probe_out2:
+	clk_notifier_unregister(ssp->clk, &ssp->clk_notifier);
+probe_out1:
+	return r;
+}
+
+static int sifive_serial_remove(struct platform_device *dev)
+{
+	struct sifive_serial_port *ssp = platform_get_drvdata(dev);
+
+	sifive_serial_remove_console_port(ssp);
+	uart_remove_one_port(&sifive_serial_uart_driver, &ssp->port);
+	free_irq(ssp->port.irq, ssp);
+	clk_notifier_unregister(ssp->clk, &ssp->clk_notifier);
+
+	return 0;
+}
+
+static const struct of_device_id sifive_serial_of_match[] = {
+	{ .compatible = "sifive,uart0" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sifive_serial_match);
+
+static struct platform_driver sifive_serial_platform_driver = {
+	.probe		= sifive_serial_probe,
+	.remove		= sifive_serial_remove,
+	.driver		= {
+		.name	= SIFIVE_SERIAL_NAME,
+		.of_match_table = of_match_ptr(sifive_serial_of_match),
+	},
+};
+
+static int __init sifive_serial_init(void)
+{
+	struct tty_driver *tty_drv;
+	int r;
+
+	r = uart_register_driver(&sifive_serial_uart_driver);
+	if (r) goto init_out1;
+
+	tty_drv = sifive_serial_uart_driver.tty_driver;
+	if (!tty_drv) goto init_out2;
+
+	/* change default terminal settings for SiFive uarts */
+	tty_drv->init_termios.c_cflag = B115200 | CS8 | CREAD | HUPCL | CLOCAL;
+	tty_drv->init_termios.c_ispeed = 115200;
+	tty_drv->init_termios.c_ospeed = 115200;
+
+	r = platform_driver_register(&sifive_serial_platform_driver);
+	if (r) goto init_out2;
+
+	return 0;
+
+init_out2:
+	uart_unregister_driver(&sifive_serial_uart_driver);
+init_out1:
+	return r;
+}
+
+static void __exit sifive_serial_exit(void)
+{
+	platform_driver_unregister(&sifive_serial_platform_driver);
+	uart_unregister_driver(&sifive_serial_uart_driver);
+}
+
+module_init(sifive_serial_init);
+module_exit(sifive_serial_exit);
+
+MODULE_DESCRIPTION("SiFive UART serial driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Paul Walmsley <paul@pwsan.com>");
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index b3d360b0ee3d..62f3871223aa 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -19,6 +19,7 @@
 #define SNOR_MFR_ATMEL		CFI_MFR_ATMEL
 #define SNOR_MFR_GIGADEVICE	0xc8
 #define SNOR_MFR_INTEL		CFI_MFR_INTEL
+#define SNOR_MFR_ISSI		0x9d
 #define SNOR_MFR_ST		CFI_MFR_ST	/* ST Micro */
 #define SNOR_MFR_MICRON		CFI_MFR_MICRON	/* Micron */
 #define SNOR_MFR_MACRONIX	CFI_MFR_MACRONIX
@@ -126,6 +127,7 @@
 #define SR_BP0			BIT(2)	/* Block protect 0 */
 #define SR_BP1			BIT(3)	/* Block protect 1 */
 #define SR_BP2			BIT(4)	/* Block protect 2 */
+#define SR_BP3			BIT(5)  /* Block protect 3 (on ISSI chips) */
 #define SR_TB			BIT(5)	/* Top/Bottom protect */
 #define SR_SRWD			BIT(7)	/* SR write protect */
 /* Spansion/Cypress specific status bits */
diff --git a/include/uapi/linux/serial_core.h b/include/uapi/linux/serial_core.h
index 6009ee2c2e99..5477e40ce6e6 100644
--- a/include/uapi/linux/serial_core.h
+++ b/include/uapi/linux/serial_core.h
@@ -287,4 +287,7 @@
 /* RDA UART */
 #define PORT_RDA	118
 
+/* SiFive UART */
+#define PORT_SIFIVE_H5U	118
+
 #endif /* _UAPILINUX_SERIAL_CORE_H */
-- 
2.19.1

